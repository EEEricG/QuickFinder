<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>拖放修复验证工具</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .test-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .test-button {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.3);
        }

        .result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }

        .result.success {
            background: rgba(34, 197, 94, 0.2);
            border: 2px solid rgba(34, 197, 94, 0.6);
        }

        .result.error {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid rgba(239, 68, 68, 0.6);
        }

        .result.info {
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid rgba(59, 130, 246, 0.6);
        }

        .fix-summary {
            background: rgba(34, 197, 94, 0.1);
            border: 2px solid rgba(34, 197, 94, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .test-instructions {
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>✅ 拖放修复验证工具</h1>
        <p>验证从右到左拖动问题的修复效果</p>
    </div>

    <!-- 修复摘要 -->
    <div class="test-section">
        <h3>🔧 修复摘要</h3>
        <div class="fix-summary">
            <h4>已修复的问题：</h4>
            <p>✅ <strong>索引计算逻辑</strong>：修复了从右到左拖动时的索引计算错误</p>
            <p>✅ <strong>调试信息增强</strong>：添加了详细的拖放调试日志</p>
            <p>✅ <strong>插入位置判断</strong>：改进了鼠标位置检测和插入线显示</p>
            <p>✅ <strong>双向拖动支持</strong>：确保从左到右和从右到左都能正常工作</p>
        </div>
        
        <button class="test-button" onclick="showFixDetails()">显示修复详情</button>
        <div id="fix-details" class="result" style="display:none;"></div>
    </div>

    <!-- 测试指南 -->
    <div class="test-section">
        <h3>🧪 测试指南</h3>
        <div class="test-instructions">
            <h4>如何测试修复效果：</h4>
            <p>1. 打开 QuickFinder 书签管理界面</p>
            <p>2. 确保有多个书签或文件夹可以拖动</p>
            <p>3. 测试以下拖动场景：</p>
            <ul>
                <li>从左到右拖动（应该继续正常工作）</li>
                <li>从右到左拖动（现在应该正确工作）</li>
                <li>拖动到目标项前面</li>
                <li>拖动到目标项后面</li>
            </ul>
            <p>4. 检查浏览器控制台的调试日志</p>
            <p>5. 验证最终的书签顺序是否符合预期</p>
        </div>
        
        <button class="test-button" onclick="showTestScenarios()">显示测试场景</button>
        <div id="test-scenarios" class="result" style="display:none;"></div>
    </div>

    <!-- 调试工具 -->
    <div class="test-section">
        <h3>🔍 调试工具</h3>
        <p>使用这些工具来验证索引计算逻辑</p>
        
        <button class="test-button" onclick="testIndexCalculation()">测试索引计算</button>
        <button class="test-button" onclick="simulateDragScenarios()">模拟拖动场景</button>
        <div id="debug-result" class="result" style="display:none;"></div>
    </div>

    <!-- 预期结果 -->
    <div class="test-section">
        <h3>🎯 预期结果</h3>
        <div class="test-instructions">
            <h4>修复后应该看到：</h4>
            <p>✅ 从右到左拖动不再失败</p>
            <p>✅ 书签被放置到可视化指示器显示的正确位置</p>
            <p>✅ 拖动方向不影响最终结果的准确性</p>
            <p>✅ 控制台显示详细的拖放调试信息</p>
            <p>✅ 书签顺序在UI和Chrome书签API中都正确保留</p>
        </div>
        
        <button class="test-button" onclick="showExpectedBehavior()">显示预期行为</button>
        <div id="expected-result" class="result" style="display:none;"></div>
    </div>

    <script>
        // 显示修复详情
        function showFixDetails() {
            const resultDiv = document.getElementById('fix-details');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result success';

            const details = `修复详情
========

1. insertItemAtPosition 函数修复：
   - 添加了详细的调试日志
   - 修复了索引计算逻辑
   - 改进了同级移动时的索引调整

2. showDragInsertLine 函数增强：
   - 添加了鼠标位置调试信息
   - 改进了插入位置判断逻辑
   - 增强了插入线显示的准确性

3. handleDrop 函数改进：
   - 添加了完整的拖放流程调试
   - 改进了错误处理和用户反馈

关键修复点：
- 索引计算时正确处理从右到左的拖动
- 只在必要时调整索引（避免过度调整）
- 增加调试信息帮助定位问题

修复前的问题：
❌ 从右到左拖动时索引计算错误
❌ 书签被放到列表末尾而非预期位置
❌ 缺乏调试信息难以定位问题

修复后的改进：
✅ 正确计算所有方向的拖动索引
✅ 书签精确放置到指示器位置
✅ 详细的调试日志帮助问题诊断`;

            resultDiv.innerHTML = details;
        }

        // 显示测试场景
        function showTestScenarios() {
            const resultDiv = document.getElementById('test-scenarios');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result info';

            const scenarios = `测试场景
========

场景1：从左到右拖动
- 将第1个书签拖到第4个书签后面
- 预期：第1个书签移动到第4个位置
- 验证：顺序变为 [2, 3, 4, 1, 5, ...]

场景2：从右到左拖动（主要修复目标）
- 将第5个书签拖到第2个书签前面
- 预期：第5个书签移动到第2个位置
- 验证：顺序变为 [1, 5, 2, 3, 4, ...]

场景3：拖动到前面
- 将任意书签拖到目标书签的左半部分
- 预期：插入线显示在目标书签左侧
- 验证：书签插入到目标书签前面

场景4：拖动到后面
- 将任意书签拖到目标书签的右半部分
- 预期：插入线显示在目标书签右侧
- 验证：书签插入到目标书签后面

场景5：文件夹拖动
- 测试文件夹的拖动重排序
- 验证：文件夹也能正确重排序

调试检查点：
1. 控制台是否显示详细的拖放日志
2. 插入线是否显示在正确位置
3. 最终书签顺序是否符合预期
4. 是否有任何JavaScript错误`;

            resultDiv.innerHTML = scenarios;
        }

        // 测试索引计算
        function testIndexCalculation() {
            const resultDiv = document.getElementById('debug-result');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result info';

            const testCases = [
                {
                    name: "从左到右拖动到后面",
                    draggedIndex: 0,
                    targetIndex: 3,
                    insertBefore: false,
                    expected: 3
                },
                {
                    name: "从右到左拖动到前面",
                    draggedIndex: 4,
                    targetIndex: 1,
                    insertBefore: true,
                    expected: 1
                },
                {
                    name: "从右到左拖动到后面",
                    draggedIndex: 4,
                    targetIndex: 1,
                    insertBefore: false,
                    expected: 2
                },
                {
                    name: "从左到右拖动到前面",
                    draggedIndex: 0,
                    targetIndex: 3,
                    insertBefore: true,
                    expected: 2
                }
            ];

            let result = `索引计算测试\n`;
            result += `============\n\n`;

            testCases.forEach((testCase, index) => {
                result += `测试 ${index + 1}: ${testCase.name}\n`;
                result += `拖动项索引: ${testCase.draggedIndex}\n`;
                result += `目标项索引: ${testCase.targetIndex}\n`;
                result += `插入位置: ${testCase.insertBefore ? '前面' : '后面'}\n`;

                // 模拟修复后的计算逻辑
                let targetIndex = testCase.targetIndex;
                if (!testCase.insertBefore) {
                    targetIndex += 1;
                }
                if (testCase.draggedIndex < targetIndex) {
                    targetIndex -= 1;
                }

                result += `计算结果: ${targetIndex}\n`;
                result += `期望结果: ${testCase.expected}\n`;
                result += `测试结果: ${targetIndex === testCase.expected ? '✅ 通过' : '❌ 失败'}\n`;
                result += `${'='.repeat(40)}\n\n`;
            });

            resultDiv.innerHTML = result;
        }

        // 模拟拖动场景
        function simulateDragScenarios() {
            const resultDiv = document.getElementById('debug-result');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result success';

            const simulation = `拖动场景模拟
============

初始顺序: [A, B, C, D, E]

场景1：A 拖到 D 后面
- 拖动项: A (索引0)
- 目标项: D (索引3)
- 插入位置: 后面
- 计算过程:
  1. 目标索引 = 3
  2. 插入到后面，索引+1 = 4
  3. 拖动项在前面，索引-1 = 3
- 结果顺序: [B, C, D, A, E] ✅

场景2：E 拖到 B 前面（修复重点）
- 拖动项: E (索引4)
- 目标项: B (索引1)
- 插入位置: 前面
- 计算过程:
  1. 目标索引 = 1
  2. 插入到前面，索引不变 = 1
  3. 拖动项在后面，不调整 = 1
- 结果顺序: [A, E, B, C, D] ✅

场景3：E 拖到 B 后面
- 拖动项: E (索引4)
- 目标项: B (索引1)
- 插入位置: 后面
- 计算过程:
  1. 目标索引 = 1
  2. 插入到后面，索引+1 = 2
  3. 拖动项在后面，不调整 = 2
- 结果顺序: [A, B, E, C, D] ✅

所有场景都应该正确工作！`;

            resultDiv.innerHTML = simulation;
        }

        // 显示预期行为
        function showExpectedBehavior() {
            const resultDiv = document.getElementById('expected-result');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result success';

            const behavior = `预期行为详细说明
================

1. 拖动开始时：
   ✅ 被拖动项变为半透明
   ✅ 鼠标指针变为移动状态

2. 拖动过程中：
   ✅ 插入线准确显示在鼠标位置对应的插入点
   ✅ 从左到右和从右到左都显示正确的插入线
   ✅ 插入线在目标项左侧（前面）或右侧（后面）

3. 放置时：
   ✅ 书签精确移动到插入线指示的位置
   ✅ 不会出现"移动到列表末尾"的错误
   ✅ 书签顺序立即更新并保存

4. 控制台日志：
   ✅ 显示拖动项和目标项信息
   ✅ 显示鼠标位置和插入位置判断
   ✅ 显示索引计算过程
   ✅ 显示最终移动结果

5. 用户体验：
   ✅ 拖动操作流畅无卡顿
   ✅ 视觉反馈清晰准确
   ✅ 操作结果符合直觉预期
   ✅ 支持撤销操作（通过浏览器书签管理）

如果看到以上所有行为，说明修复成功！`;

            resultDiv.innerHTML = behavior;
        }
    </script>
</body>
</html>
