<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Import Fix Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .test-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .test-button {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.3);
        }

        .result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }

        .result.success {
            background: rgba(34, 197, 94, 0.2);
            border: 2px solid rgba(34, 197, 94, 0.6);
        }

        .result.error {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid rgba(239, 68, 68, 0.6);
        }

        .result.info {
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid rgba(59, 130, 246, 0.6);
        }

        .file-input {
            margin: 10px 0;
            padding: 10px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            text-align: center;
        }

        .progress-demo {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .progress-bar-demo {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill-demo {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ Complete Import Fix Test</h1>
        <p>Test both folder structure fix and progress indicator functionality</p>
    </div>

    <!-- Progress Indicator Demo -->
    <div class="test-section">
        <h3>üìä Progress Indicator Demo</h3>
        <p>Test the new progress indicator functionality</p>
        <button class="test-button" onclick="demoProgressIndicator()">Demo Progress Indicator</button>
        <div class="progress-demo" id="progress-demo" style="display:none;">
            <div>Status: <span id="demo-status">Initializing...</span></div>
            <div class="progress-bar-demo">
                <div class="progress-fill-demo" id="demo-fill"></div>
            </div>
            <div>Progress: <span id="demo-percentage">0%</span></div>
        </div>
    </div>

    <!-- Path Extraction Test -->
    <div class="test-section">
        <h3>üîç Path Extraction Test</h3>
        <div class="file-input">
            <input type="file" id="bookmark-file" accept=".html" onchange="testPathExtraction(event)">
            <p>Select your bookmarks_2025-06-27.html file</p>
        </div>
        <button class="test-button" onclick="testWithSampleData()">Test with Sample Data</button>
        <div id="path-test-result" class="result" style="display:none;"></div>
    </div>

    <!-- Folder Mapping Test -->
    <div class="test-section">
        <h3>üóÇÔ∏è Folder Mapping Test</h3>
        <button class="test-button" onclick="testFolderMapping()">Test Folder Creation & Mapping</button>
        <div id="folder-mapping-result" class="result" style="display:none;"></div>
    </div>

    <!-- Complete Import Test -->
    <div class="test-section">
        <h3>üöÄ Complete Import Test</h3>
        <p>Test the complete import process with progress tracking</p>
        <button class="test-button" onclick="testCompleteImport()">Run Complete Import Test</button>
        <div id="complete-import-result" class="result" style="display:none;"></div>
    </div>

    <script>
        let globalBookmarkData = null;

        // Demo progress indicator
        function demoProgressIndicator() {
            const demoDiv = document.getElementById('progress-demo');
            const statusEl = document.getElementById('demo-status');
            const fillEl = document.getElementById('demo-fill');
            const percentageEl = document.getElementById('demo-percentage');

            demoDiv.style.display = 'block';

            const steps = [
                { status: 'Reading file...', progress: 5 },
                { status: 'Parsing bookmarks...', progress: 15 },
                { status: 'Creating folders...', progress: 30 },
                { status: 'Creating work-assist folder...', progress: 40 },
                { status: 'Creating AI-Chat folder...', progress: 50 },
                { status: 'Importing bookmarks...', progress: 70 },
                { status: 'Importing to work-assist...', progress: 85 },
                { status: 'Finalizing...', progress: 95 },
                { status: 'Complete!', progress: 100 }
            ];

            let currentStep = 0;

            function updateDemo() {
                if (currentStep < steps.length) {
                    const step = steps[currentStep];
                    statusEl.textContent = step.status;
                    fillEl.style.width = `${step.progress}%`;
                    percentageEl.textContent = `${step.progress}%`;
                    currentStep++;
                    setTimeout(updateDemo, 800);
                } else {
                    setTimeout(() => {
                        demoDiv.style.display = 'none';
                    }, 2000);
                }
            }

            updateDemo();
        }

        // Test path extraction
        async function testPathExtraction(event) {
            const resultDiv = document.getElementById('path-test-result');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = 'üîÑ Testing path extraction...';
            resultDiv.className = 'result info';

            try {
                const file = event.target.files[0];
                if (!file) return;

                const content = await readFileContent(file);
                const bookmarks = parseBookmarkHTMLFixed(content);
                globalBookmarkData = bookmarks;

                let analysis = `Path Extraction Test Results\n`;
                analysis += `============================\n\n`;
                analysis += `File: ${file.name}\n`;
                analysis += `Total items: ${bookmarks.length}\n`;

                const bookmarkItems = bookmarks.filter(b => b.type === 'bookmark');
                const folderItems = bookmarks.filter(b => b.type === 'folder');

                analysis += `Bookmarks: ${bookmarkItems.length}\n`;
                analysis += `Folders: ${folderItems.length}\n\n`;

                // Analyze path distribution
                const pathDistribution = {};
                bookmarkItems.forEach(bookmark => {
                    const pathKey = bookmark.path.length > 0 ? bookmark.path.join(' > ') : 'ROOT';
                    pathDistribution[pathKey] = (pathDistribution[pathKey] || 0) + 1;
                });

                analysis += `Path Distribution:\n`;
                Object.entries(pathDistribution).forEach(([path, count]) => {
                    analysis += `- "${path}": ${count} bookmarks\n`;
                });

                // Check for proper folder structure
                const hasProperPaths = Object.keys(pathDistribution).length > 1;
                const rootBookmarks = pathDistribution['ROOT'] || 0;

                analysis += `\nPath Extraction Analysis:\n`;
                if (hasProperPaths && rootBookmarks < bookmarkItems.length * 0.3) {
                    analysis += `‚úÖ EXCELLENT: Most bookmarks have proper folder paths!\n`;
                    analysis += `   This should resolve the folder structure issue.\n`;
                    resultDiv.className = 'result success';
                } else if (hasProperPaths) {
                    analysis += `‚ö†Ô∏è PARTIAL: Some bookmarks have paths, but many are still in root.\n`;
                    analysis += `   Path extraction needs further improvement.\n`;
                    resultDiv.className = 'result info';
                } else {
                    analysis += `‚ùå FAILED: All bookmarks are still being placed in root.\n`;
                    analysis += `   Path extraction logic is not working correctly.\n`;
                    resultDiv.className = 'result error';
                }

                // Show sample bookmarks with paths
                analysis += `\nSample Bookmarks with Paths:\n`;
                bookmarkItems.slice(0, 10).forEach((bookmark, index) => {
                    const pathStr = bookmark.path.length > 0 ? bookmark.path.join(' > ') : 'ROOT';
                    analysis += `${index + 1}. ${bookmark.title}\n`;
                    analysis += `   Path: ${pathStr}\n`;
                });

                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `‚ùå Path extraction test failed: ${error.message}`;
            }
        }

        // Test with sample data
        function testWithSampleData() {
            const resultDiv = document.getElementById('path-test-result');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = 'üîÑ Testing with sample data...';
            resultDiv.className = 'result info';

            const sampleHTML = `<!DOCTYPE NETSCAPE-Bookmark-file-1>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DL><p>
<DT><H3>Untitled Folder</H3>
<DL><p>
  <DT><H3>Êî∂ËóèÂ§πÊ†è</H3>
  <DL><p>
    <DT><H3>work-assist</H3>
    <DL><p>
      <DT><A HREF="https://aflowmind.com/app/mindmap/6E1-YDYVBAN4ORDO7PSH">AflowMind: The AI Mind Mapping Tool</A>
      <DT><A HREF="https://app.amymind.com/mindmap/new">AmyMind</A>
    </DL><p>
    <DT><H3>AI-Chat</H3>
    <DL><p>
      <DT><A HREF="https://chat.openai.com/chat">ChatGPT</A>
      <DT><A HREF="https://gemini.google.com/u/1/app/74a659aed20881f2">Gemini Advanced</A>
    </DL><p>
    <DT><A HREF="https://github.com/">GitHub</A>
    <DT><A HREF="https://www.google.com/">Google</A>
  </DL><p>
</DL><p>
</DL><p>`;

            try {
                const bookmarks = parseBookmarkHTMLFixed(sampleHTML);
                globalBookmarkData = bookmarks;

                let analysis = `Sample Data Test Results\n`;
                analysis += `========================\n\n`;
                analysis += `Expected Structure:\n`;
                analysis += `- Êî∂ËóèÂ§πÊ†è > work-assist: 2 bookmarks\n`;
                analysis += `- Êî∂ËóèÂ§πÊ†è > AI-Chat: 2 bookmarks\n`;
                analysis += `- Êî∂ËóèÂ§πÊ†è: 2 bookmarks\n\n`;

                analysis += `Actual Results:\n`;
                const bookmarkItems = bookmarks.filter(b => b.type === 'bookmark');
                bookmarkItems.forEach((bookmark, index) => {
                    const pathStr = bookmark.path.length > 0 ? bookmark.path.join(' > ') : 'ROOT';
                    analysis += `${index + 1}. ${bookmark.title}\n`;
                    analysis += `   Path: ${pathStr}\n`;
                });

                // Verify expected paths
                const workAssistBookmarks = bookmarkItems.filter(b => 
                    b.path.includes('work-assist')
                ).length;
                const aiChatBookmarks = bookmarkItems.filter(b => 
                    b.path.includes('AI-Chat')
                ).length;
                const rootBookmarks = bookmarkItems.filter(b => 
                    b.path.length === 1 && b.path[0] === 'Êî∂ËóèÂ§πÊ†è'
                ).length;

                analysis += `\nVerification:\n`;
                analysis += `work-assist bookmarks: ${workAssistBookmarks} (expected: 2)\n`;
                analysis += `AI-Chat bookmarks: ${aiChatBookmarks} (expected: 2)\n`;
                analysis += `Êî∂ËóèÂ§πÊ†è root bookmarks: ${rootBookmarks} (expected: 2)\n`;

                if (workAssistBookmarks === 2 && aiChatBookmarks === 2 && rootBookmarks === 2) {
                    analysis += `\nüéâ PERFECT! Path extraction is working correctly!`;
                    resultDiv.className = 'result success';
                } else if (workAssistBookmarks > 0 || aiChatBookmarks > 0) {
                    analysis += `\n‚úÖ GOOD! Path extraction is partially working.`;
                    resultDiv.className = 'result info';
                } else {
                    analysis += `\n‚ùå FAILED! Path extraction is not working.`;
                    resultDiv.className = 'result error';
                }

                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `‚ùå Sample test failed: ${error.message}`;
            }
        }

        // Test folder mapping
        async function testFolderMapping() {
            const resultDiv = document.getElementById('folder-mapping-result');
            resultDiv.style.display = 'block';

            if (!globalBookmarkData) {
                resultDiv.innerHTML = '‚ùå Please run path extraction test first';
                resultDiv.className = 'result error';
                return;
            }

            resultDiv.innerHTML = 'üîÑ Testing folder creation and mapping...';
            resultDiv.className = 'result info';

            try {
                // Create test folder
                const testFolder = await chrome.bookmarks.create({
                    parentId: '1',
                    title: `Folder_Mapping_Test_${Date.now()}`
                });

                let analysis = `Folder Mapping Test\n`;
                analysis += `==================\n\n`;
                analysis += `Test folder: ${testFolder.title} (ID: ${testFolder.id})\n\n`;

                // Simulate folder creation logic
                const folders = globalBookmarkData.filter(b => b.type === 'folder');
                folders.sort((a, b) => a.path.length - b.path.length);

                const folderMap = new Map();
                folderMap.set('', testFolder.id);

                analysis += `Creating ${folders.length} folders in dependency order:\n`;

                for (let i = 0; i < Math.min(folders.length, 5); i++) {
                    const folder = folders[i];
                    const pathKey = folder.path.join('/');
                    const parentFolderId = folderMap.get(pathKey) || testFolder.id;

                    try {
                        const createdFolder = await chrome.bookmarks.create({
                            parentId: parentFolderId,
                            title: folder.title
                        });

                        const currentPathKey = [...folder.path, folder.title].join('/');
                        folderMap.set(currentPathKey, createdFolder.id);

                        analysis += `‚úÖ ${folder.title}\n`;
                        analysis += `   Path: [${folder.path.join(' > ')}]\n`;
                        analysis += `   Parent ID: ${parentFolderId}\n`;
                        analysis += `   Created ID: ${createdFolder.id}\n`;
                        analysis += `   Mapping: "${currentPathKey}" -> ${createdFolder.id}\n\n`;

                    } catch (error) {
                        analysis += `‚ùå ${folder.title}: ${error.message}\n\n`;
                    }
                }

                analysis += `Final folder mapping:\n`;
                for (const [path, id] of folderMap.entries()) {
                    analysis += `"${path}" -> ${id}\n`;
                }

                resultDiv.className = 'result success';
                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `‚ùå Folder mapping test failed: ${error.message}`;
            }
        }

        // Test complete import
        async function testCompleteImport() {
            const resultDiv = document.getElementById('complete-import-result');
            resultDiv.style.display = 'block';

            if (!globalBookmarkData) {
                resultDiv.innerHTML = '‚ùå Please run path extraction test first';
                resultDiv.className = 'result error';
                return;
            }

            resultDiv.innerHTML = 'üîÑ Running complete import test...';
            resultDiv.className = 'result info';

            try {
                const bookmarkItems = globalBookmarkData.filter(b => b.type === 'bookmark');
                const folderItems = globalBookmarkData.filter(b => b.type === 'folder');

                let analysis = `Complete Import Test\n`;
                analysis += `===================\n\n`;
                analysis += `Data to import:\n`;
                analysis += `- Bookmarks: ${bookmarkItems.length}\n`;
                analysis += `- Folders: ${folderItems.length}\n\n`;

                // Check if the new import function exists
                if (typeof chrome !== 'undefined' && chrome.bookmarks) {
                    analysis += `‚úÖ Chrome bookmarks API available\n`;
                    analysis += `‚úÖ Ready for actual import test\n\n`;
                    
                    analysis += `To test the complete import with progress indicator:\n`;
                    analysis += `1. Go to the QuickFinder bookmark management page\n`;
                    analysis += `2. Use the import function with your bookmarks file\n`;
                    analysis += `3. You should see:\n`;
                    analysis += `   - Progress modal with real-time updates\n`;
                    analysis += `   - Folders created in correct hierarchy\n`;
                    analysis += `   - Bookmarks placed in proper folders\n`;
                    analysis += `   - No more "all bookmarks in root" issue\n\n`;
                    
                    analysis += `Expected folder structure after import:\n`;
                    const pathDistribution = {};
                    bookmarkItems.forEach(bookmark => {
                        const pathKey = bookmark.path.length > 0 ? bookmark.path.join(' > ') : 'ROOT';
                        pathDistribution[pathKey] = (pathDistribution[pathKey] || 0) + 1;
                    });
                    
                    Object.entries(pathDistribution).forEach(([path, count]) => {
                        analysis += `- "${path}": ${count} bookmarks\n`;
                    });
                    
                    resultDiv.className = 'result success';
                } else {
                    analysis += `‚ö†Ô∏è Chrome bookmarks API not available in this context\n`;
                    analysis += `This test needs to be run in the extension environment\n`;
                    resultDiv.className = 'result info';
                }

                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `‚ùå Complete import test failed: ${error.message}`;
            }
        }

        // Helper functions
        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('File read failed'));
                reader.readAsText(file, 'UTF-8');
            });
        }

        // Fixed parsing function (copy from the updated bookmarks.js)
        function parseBookmarkHTMLFixed(htmlContent) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const bookmarks = [];

            // Direct extraction of all bookmarks
            const allLinks = doc.querySelectorAll('dt a[href]');
            allLinks.forEach((link) => {
                if (link.href && link.href.startsWith('http')) {
                    const path = getBookmarkPathFixed(link);
                    bookmarks.push({
                        type: 'bookmark',
                        title: link.textContent.trim() || 'Untitled',
                        url: link.href,
                        path: path
                    });
                }
            });

            // Extract folders
            const allFolders = doc.querySelectorAll('dt h3');
            allFolders.forEach((folderElement) => {
                const folderName = folderElement.textContent.trim();
                if (folderName !== 'Untitled Folder') {
                    const path = getFolderPathFixed(folderElement);
                    bookmarks.push({
                        type: 'folder',
                        title: folderName,
                        path: path
                    });
                }
            });

            return bookmarks;
        }

        function getBookmarkPathFixed(linkElement) {
            const path = [];
            let current = linkElement;
            
            while (current && current.parentElement) {
                current = current.parentElement;
                
                if (current.tagName === 'DL') {
                    let folderDT = current.previousElementSibling;
                    
                    while (folderDT && folderDT.nodeType !== Node.ELEMENT_NODE) {
                        folderDT = folderDT.previousSibling;
                    }
                    
                    if (folderDT && folderDT.tagName === 'DT') {
                        const folderH3 = folderDT.querySelector('h3');
                        if (folderH3) {
                            const folderName = folderH3.textContent.trim();
                            if (folderName !== 'Untitled Folder') {
                                path.unshift(folderName);
                            }
                        }
                    }
                }
            }
            
            return path;
        }

        function getFolderPathFixed(folderElement) {
            const path = [];
            const folderName = folderElement.textContent.trim();
            let current = folderElement;
            
            while (current && current.parentElement) {
                current = current.parentElement;
                
                if (current.tagName === 'DL') {
                    let folderDT = current.previousElementSibling;
                    
                    while (folderDT && folderDT.nodeType !== Node.ELEMENT_NODE) {
                        folderDT = folderDT.previousSibling;
                    }
                    
                    if (folderDT && folderDT.tagName === 'DT') {
                        const parentFolderH3 = folderDT.querySelector('h3');
                        if (parentFolderH3) {
                            const parentFolderName = parentFolderH3.textContent.trim();
                            if (parentFolderName !== 'Untitled Folder' && parentFolderName !== folderName) {
                                path.unshift(parentFolderName);
                            }
                        }
                    }
                }
            }
            
            return path;
        }
    </script>
</body>
</html>
