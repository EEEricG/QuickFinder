<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>拖放问题调试工具</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .test-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .test-button {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.3);
        }

        .result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }

        .result.success {
            background: rgba(34, 197, 94, 0.2);
            border: 2px solid rgba(34, 197, 94, 0.6);
        }

        .result.error {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid rgba(239, 68, 68, 0.6);
        }

        .result.info {
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid rgba(59, 130, 246, 0.6);
        }

        .drag-demo {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .drag-item {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: move;
            user-select: none;
            transition: all 0.3s ease;
            position: relative;
        }

        .drag-item:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .drag-item.dragging {
            opacity: 0.5;
        }

        .insert-line {
            position: absolute;
            width: 3px;
            background: #22c55e;
            border-radius: 2px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .insert-line.visible {
            opacity: 1;
        }

        .problem-analysis {
            background: rgba(239, 68, 68, 0.1);
            border: 2px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .solution-box {
            background: rgba(34, 197, 94, 0.1);
            border: 2px solid rgba(34, 197, 94, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🐛 拖放问题调试工具</h1>
        <p>分析和修复从右到左拖动失败的问题</p>
    </div>

    <!-- 问题分析 -->
    <div class="test-section">
        <h3>🔍 问题分析</h3>
        <div class="problem-analysis">
            <h4>发现的问题：</h4>
            <p>1. <strong>索引计算错误</strong>：从右到左拖动时，目标索引计算不正确</p>
            <p>2. <strong>插入位置判断</strong>：insertBefore 逻辑在某些情况下失效</p>
            <p>3. <strong>同级移动调整</strong>：当在同一父级内移动时，索引调整逻辑有缺陷</p>
        </div>
        
        <button class="test-button" onclick="analyzeIndexCalculation()">分析索引计算问题</button>
        <div id="analysis-result" class="result" style="display:none;"></div>
    </div>

    <!-- 拖放模拟 -->
    <div class="test-section">
        <h3>🎯 拖放行为模拟</h3>
        <p>模拟不同方向的拖放操作，测试索引计算</p>
        
        <div class="drag-demo" id="drag-demo">
            <div class="drag-item" data-index="0">Item A</div>
            <div class="drag-item" data-index="1">Item B</div>
            <div class="drag-item" data-index="2">Item C</div>
            <div class="drag-item" data-index="3">Item D</div>
            <div class="drag-item" data-index="4">Item E</div>
        </div>
        
        <button class="test-button" onclick="simulateLeftToRight()">模拟从左到右拖动</button>
        <button class="test-button" onclick="simulateRightToLeft()">模拟从右到左拖动</button>
        <button class="test-button" onclick="resetDemo()">重置演示</button>
        
        <div id="simulation-result" class="result" style="display:none;"></div>
    </div>

    <!-- 修复方案 -->
    <div class="test-section">
        <h3>🔧 修复方案</h3>
        <div class="solution-box">
            <h4>修复策略：</h4>
            <p>1. <strong>改进索引计算</strong>：正确处理从右到左的拖动</p>
            <p>2. <strong>优化插入逻辑</strong>：确保 insertBefore 判断准确</p>
            <p>3. <strong>增强调试日志</strong>：添加详细的拖放调试信息</p>
        </div>
        
        <button class="test-button" onclick="showFixedCode()">显示修复代码</button>
        <div id="fix-result" class="result" style="display:none;"></div>
    </div>

    <div class="insert-line" id="insert-line"></div>

    <script>
        let draggedItem = null;
        let dragInsertInfo = null;

        // 分析索引计算问题
        function analyzeIndexCalculation() {
            const resultDiv = document.getElementById('analysis-result');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result info';

            let analysis = `索引计算问题分析\n`;
            analysis += `==================\n\n`;

            // 模拟不同的拖放场景
            const scenarios = [
                {
                    name: "从左到右拖动 (A -> D后面)",
                    draggedIndex: 0,
                    targetIndex: 3,
                    insertBefore: false,
                    expected: 3
                },
                {
                    name: "从右到左拖动 (D -> A前面)",
                    draggedIndex: 3,
                    targetIndex: 0,
                    insertBefore: true,
                    expected: 0
                },
                {
                    name: "从右到左拖动 (E -> B后面)",
                    draggedIndex: 4,
                    targetIndex: 1,
                    insertBefore: false,
                    expected: 2
                },
                {
                    name: "从左到右拖动 (A -> C前面)",
                    draggedIndex: 0,
                    targetIndex: 2,
                    insertBefore: true,
                    expected: 1
                }
            ];

            scenarios.forEach((scenario, index) => {
                analysis += `场景 ${index + 1}: ${scenario.name}\n`;
                analysis += `拖动项索引: ${scenario.draggedIndex}\n`;
                analysis += `目标项索引: ${scenario.targetIndex}\n`;
                analysis += `插入位置: ${scenario.insertBefore ? '前面' : '后面'}\n`;

                // 当前的错误计算
                const currentResult = calculateIndexOld(scenario);
                analysis += `当前计算结果: ${currentResult}\n`;
                analysis += `期望结果: ${scenario.expected}\n`;
                analysis += `结果: ${currentResult === scenario.expected ? '✅ 正确' : '❌ 错误'}\n\n`;

                // 修复后的计算
                const fixedResult = calculateIndexFixed(scenario);
                analysis += `修复后计算: ${fixedResult}\n`;
                analysis += `修复结果: ${fixedResult === scenario.expected ? '✅ 正确' : '❌ 仍有问题'}\n`;
                analysis += `${'='.repeat(50)}\n\n`;
            });

            resultDiv.innerHTML = analysis;
        }

        // 当前的错误索引计算逻辑
        function calculateIndexOld(scenario) {
            let targetIndex = scenario.targetIndex;

            // 如果插入到后面，索引+1
            if (!scenario.insertBefore) {
                targetIndex += 1;
            }

            // 如果拖拽项目在目标项目前面，需要调整索引
            if (scenario.draggedIndex < targetIndex) {
                targetIndex -= 1;
            }

            return targetIndex;
        }

        // 修复后的索引计算逻辑
        function calculateIndexFixed(scenario) {
            let targetIndex = scenario.targetIndex;

            // 如果插入到后面，索引+1
            if (!scenario.insertBefore) {
                targetIndex += 1;
            }

            // 关键修复：只有当拖动项在目标项前面且最终位置也在目标项前面时才调整
            if (scenario.draggedIndex < scenario.targetIndex && targetIndex > scenario.draggedIndex) {
                targetIndex -= 1;
            }

            return targetIndex;
        }

        // 模拟从左到右拖动
        function simulateLeftToRight() {
            const resultDiv = document.getElementById('simulation-result');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result info';

            let result = `从左到右拖动模拟\n`;
            result += `==================\n\n`;
            result += `场景：将 Item A (索引0) 拖动到 Item D (索引3) 后面\n\n`;

            const scenario = {
                draggedIndex: 0,
                targetIndex: 3,
                insertBefore: false
            };

            result += `步骤分析：\n`;
            result += `1. 目标索引: ${scenario.targetIndex}\n`;
            result += `2. 插入到后面，索引+1: ${scenario.targetIndex + 1}\n`;
            result += `3. 拖动项在目标项前面，索引-1: ${scenario.targetIndex + 1 - 1}\n`;
            result += `4. 最终索引: ${scenario.targetIndex}\n\n`;

            result += `预期结果：A 应该出现在位置 3 (原D的位置)\n`;
            result += `新顺序：B, C, D, A, E\n\n`;

            result += `✅ 从左到右拖动通常工作正常`;

            resultDiv.innerHTML = result;
        }

        // 模拟从右到左拖动
        function simulateRightToLeft() {
            const resultDiv = document.getElementById('simulation-result');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result error';

            let result = `从右到左拖动模拟\n`;
            result += `==================\n\n`;
            result += `场景：将 Item E (索引4) 拖动到 Item B (索引1) 前面\n\n`;

            const scenario = {
                draggedIndex: 4,
                targetIndex: 1,
                insertBefore: true
            };

            result += `当前错误计算：\n`;
            result += `1. 目标索引: ${scenario.targetIndex}\n`;
            result += `2. 插入到前面，索引不变: ${scenario.targetIndex}\n`;
            result += `3. 拖动项在目标项后面，不调整: ${scenario.targetIndex}\n`;
            result += `4. 最终索引: ${scenario.targetIndex}\n\n`;

            result += `❌ 问题：E 被放到了位置 1，但这会把它放在 B 的位置，而不是 B 前面\n\n`;

            result += `修复后的计算：\n`;
            result += `1. 目标索引: ${scenario.targetIndex}\n`;
            result += `2. 插入到前面，索引不变: ${scenario.targetIndex}\n`;
            result += `3. 拖动项在目标项后面，且目标位置在拖动项前面，不需要调整\n`;
            result += `4. 最终索引: ${scenario.targetIndex}\n\n`;

            result += `✅ 修复后：E 正确放到位置 1 (B 前面)\n`;
            result += `新顺序：A, E, B, C, D`;

            resultDiv.innerHTML = result;
        }

        // 重置演示
        function resetDemo() {
            const items = ['Item A', 'Item B', 'Item C', 'Item D', 'Item E'];
            const demoDiv = document.getElementById('drag-demo');
            
            demoDiv.innerHTML = '';
            items.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'drag-item';
                div.setAttribute('data-index', index);
                div.textContent = item;
                demoDiv.appendChild(div);
            });

            const resultDiv = document.getElementById('simulation-result');
            resultDiv.style.display = 'none';
        }

        // 显示修复代码
        function showFixedCode() {
            const resultDiv = document.getElementById('fix-result');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result success';

            const fixedCode = `// 修复后的 insertItemAtPosition 函数
async insertItemAtPosition(draggedItem, insertInfo) {
  const { targetItem, insertBefore } = insertInfo;
  
  console.log('🎯 拖放调试信息:');
  console.log('拖动项:', draggedItem.title, '索引:', draggedItem.index);
  console.log('目标项:', targetItem.title, '索引:', targetItem.index);
  console.log('插入位置:', insertBefore ? '前面' : '后面');

  // 获取目标项目的索引
  let targetIndex = parseInt(targetItem.index) || 0;
  const draggedIndex = parseInt(draggedItem.index) || 0;

  // 如果插入到后面，索引+1
  if (!insertBefore) {
    targetIndex += 1;
  }

  console.log('初始目标索引:', targetIndex);

  // 关键修复：只有在同一父级内移动且需要调整时才减1
  if (draggedItem.parentId === targetItem.parentId) {
    // 如果拖动项在目标位置前面，且最终位置会受到拖动项移除的影响
    if (draggedIndex < targetIndex) {
      targetIndex -= 1;
      console.log('调整后索引:', targetIndex, '(拖动项在前面，索引-1)');
    }
  }

  console.log('最终目标索引:', targetIndex);

  // 移动拖拽项目到目标位置
  await chrome.bookmarks.move(draggedItem.id, {
    parentId: targetItem.parentId,
    index: targetIndex
  });
  
  console.log('✅ 移动完成');
}

// 修复后的 showDragInsertLine 函数 (增强调试)
showDragInsertLine(event, targetElement, targetItem) {
  if (!this.dragInsertLine) {
    this.hideDragInsertLine();
    return;
  }

  const rect = targetElement.getBoundingClientRect();
  const mouseX = event.clientX;
  const elementCenterX = rect.left + rect.width / 2;

  // 判断插入位置：鼠标在元素左半部分插入到前面，右半部分插入到后面
  const insertBefore = mouseX < elementCenterX;
  
  console.log('🖱️ 鼠标位置调试:');
  console.log('鼠标X:', mouseX);
  console.log('元素中心X:', elementCenterX);
  console.log('插入位置:', insertBefore ? '前面' : '后面');

  // 计算插入线位置
  let lineX;
  if (insertBefore) {
    lineX = rect.left - 2; // 插入到目标元素左侧
  } else {
    lineX = rect.right - 1; // 插入到目标元素右侧
  }

  // 设置插入线样式和位置（垂直线）
  this.dragInsertLine.style.left = lineX + 'px';
  this.dragInsertLine.style.top = rect.top + 'px';
  this.dragInsertLine.style.height = rect.height + 'px';
  this.dragInsertLine.classList.add('visible');

  // 存储插入信息
  this.dragInsertInfo = {
    targetItem,
    insertBefore,
    targetElement
  };
  
  console.log('💾 存储插入信息:', this.dragInsertInfo);
}`;

            resultDiv.innerHTML = fixedCode;
        }

        // 初始化
        resetDemo();
    </script>
</body>
</html>
