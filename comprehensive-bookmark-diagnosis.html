<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Bookmark Import Diagnosis</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .diagnostic-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .test-button {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3);
        }

        .result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }

        .result.success {
            background: rgba(34, 197, 94, 0.2);
            border: 2px solid rgba(34, 197, 94, 0.6);
        }

        .result.error {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid rgba(239, 68, 68, 0.6);
        }

        .result.info {
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid rgba(59, 130, 246, 0.6);
        }

        .result.warning {
            background: rgba(245, 158, 11, 0.2);
            border: 2px solid rgba(245, 158, 11, 0.6);
        }

        .file-input {
            margin: 10px 0;
            padding: 10px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            text-align: center;
        }

        .step-indicator {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ”¬ Comprehensive Bookmark Import Diagnosis</h1>
        <p>Deep analysis of bookmarks_2025-06-27.html import issues</p>
    </div>

    <!-- Step 1: File Format Analysis -->
    <div class="diagnostic-section">
        <div class="section-title">
            <span class="step-indicator">Step 1</span>
            ðŸ“„ File Format Analysis
        </div>
        <p>Analyze the structure and format compliance of your bookmark file</p>
        <div class="file-input">
            <input type="file" id="bookmark-file" accept=".html" onchange="analyzeFileFormat(event)">
            <p>Select your bookmarks_2025-06-27.html file</p>
        </div>
        <div id="format-analysis" class="result" style="display:none;"></div>
    </div>

    <!-- Step 2: Parsing Logic Test -->
    <div class="diagnostic-section">
        <div class="section-title">
            <span class="step-indicator">Step 2</span>
            ðŸ§© Parsing Logic Test
        </div>
        <p>Test the current parsing logic with your file structure</p>
        <button class="test-button" onclick="testParsingLogic()">Test Current Parser</button>
        <button class="test-button" onclick="testAlternativeParser()">Test Alternative Parser</button>
        <div id="parsing-test" class="result" style="display:none;"></div>
    </div>

    <!-- Step 3: Chrome API Simulation -->
    <div class="diagnostic-section">
        <div class="section-title">
            <span class="step-indicator">Step 3</span>
            ðŸ”§ Chrome API Import Simulation
        </div>
        <p>Simulate the actual Chrome bookmark creation process</p>
        <button class="test-button" onclick="simulateImport()">Simulate Full Import</button>
        <button class="test-button" onclick="testSingleBookmark()">Test Single Bookmark Creation</button>
        <div id="import-simulation" class="result" style="display:none;"></div>
    </div>

    <!-- Step 4: Root Cause Analysis -->
    <div class="diagnostic-section">
        <div class="section-title">
            <span class="step-indicator">Step 4</span>
            ðŸŽ¯ Root Cause Analysis
        </div>
        <div id="root-cause-analysis" class="result" style="display:none;"></div>
    </div>

    <script>
        let globalBookmarkData = null;
        let globalFileContent = null;

        // Step 1: Analyze file format
        async function analyzeFileFormat(event) {
            const resultDiv = document.getElementById('format-analysis');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = 'ðŸ”„ Analyzing file format...';
            resultDiv.className = 'result info';

            try {
                const file = event.target.files[0];
                if (!file) return;

                const content = await readFileContent(file);
                globalFileContent = content;

                let analysis = `FILE FORMAT ANALYSIS\n`;
                analysis += `==================\n\n`;
                analysis += `File: ${file.name}\n`;
                analysis += `Size: ${file.size} bytes\n`;
                analysis += `Type: ${file.type}\n\n`;

                // Check DOCTYPE
                const hasCorrectDoctype = content.includes('<!DOCTYPE NETSCAPE-Bookmark-file-1>');
                analysis += `âœ“ DOCTYPE: ${hasCorrectDoctype ? 'CORRECT' : 'MISSING/INCORRECT'}\n`;

                // Check basic structure
                const hasTitle = content.includes('<TITLE>');
                const hasH1 = content.includes('<H1>');
                const hasDL = content.includes('<DL>');
                const hasDT = content.includes('<DT>');

                analysis += `âœ“ Title tag: ${hasTitle ? 'PRESENT' : 'MISSING'}\n`;
                analysis += `âœ“ H1 tag: ${hasH1 ? 'PRESENT' : 'MISSING'}\n`;
                analysis += `âœ“ DL tags: ${hasDL ? 'PRESENT' : 'MISSING'}\n`;
                analysis += `âœ“ DT tags: ${hasDT ? 'PRESENT' : 'MISSING'}\n\n`;

                // Count elements
                const dlCount = (content.match(/<DL>/gi) || []).length;
                const dtCount = (content.match(/<DT>/gi) || []).length;
                const linkCount = (content.match(/<A HREF=/gi) || []).length;
                const folderCount = (content.match(/<H3>/gi) || []).length;

                analysis += `ELEMENT COUNTS:\n`;
                analysis += `- DL elements: ${dlCount}\n`;
                analysis += `- DT elements: ${dtCount}\n`;
                analysis += `- Links (A HREF): ${linkCount}\n`;
                analysis += `- Folders (H3): ${folderCount}\n\n`;

                // Check nesting structure
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'text/html');
                const rootDL = doc.querySelector('dl');
                
                if (rootDL) {
                    const depth = getMaxNestingDepth(rootDL);
                    analysis += `NESTING ANALYSIS:\n`;
                    analysis += `- Maximum nesting depth: ${depth} levels\n`;
                    analysis += `- Root DL found: YES\n`;
                    
                    // Check for "Untitled Folder"
                    const untitledFolder = doc.querySelector('h3');
                    if (untitledFolder && untitledFolder.textContent.includes('Untitled Folder')) {
                        analysis += `- Contains "Untitled Folder": YES (this may need special handling)\n`;
                    }
                } else {
                    analysis += `- Root DL found: NO (PROBLEM!)\n`;
                }

                // Format compliance check
                analysis += `\nFORMAT COMPLIANCE:\n`;
                const isStandardFormat = hasCorrectDoctype && hasTitle && hasH1 && hasDL && hasDT;
                analysis += `- Standard Netscape format: ${isStandardFormat ? 'COMPLIANT' : 'NON-COMPLIANT'}\n`;
                
                if (linkCount > 0) {
                    analysis += `- Contains bookmarks: YES (${linkCount} links found)\n`;
                } else {
                    analysis += `- Contains bookmarks: NO (MAJOR PROBLEM!)\n`;
                }

                resultDiv.className = isStandardFormat && linkCount > 0 ? 'result success' : 'result warning';
                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `âŒ File analysis failed: ${error.message}`;
            }
        }

        // Step 2: Test parsing logic
        async function testParsingLogic() {
            const resultDiv = document.getElementById('parsing-test');
            resultDiv.style.display = 'block';
            
            if (!globalFileContent) {
                resultDiv.innerHTML = 'âŒ Please select a file first in Step 1';
                resultDiv.className = 'result error';
                return;
            }

            resultDiv.innerHTML = 'ðŸ”„ Testing current parsing logic...';
            resultDiv.className = 'result info';

            try {
                console.log('ðŸ§ª Starting parsing test...');
                const bookmarks = parseBookmarkHTML(globalFileContent);
                globalBookmarkData = bookmarks;

                let analysis = `PARSING LOGIC TEST RESULTS\n`;
                analysis += `==========================\n\n`;
                analysis += `Total items parsed: ${bookmarks.length}\n\n`;

                // Categorize results
                const bookmarkItems = bookmarks.filter(b => b.type === 'bookmark');
                const folderItems = bookmarks.filter(b => b.type === 'folder');

                analysis += `BREAKDOWN:\n`;
                analysis += `- Bookmarks: ${bookmarkItems.length}\n`;
                analysis += `- Folders: ${folderItems.length}\n\n`;

                if (bookmarkItems.length === 0) {
                    analysis += `âŒ CRITICAL ISSUE: No bookmarks parsed!\n`;
                    analysis += `This indicates a parsing logic problem.\n\n`;
                } else if (bookmarkItems.length === 1) {
                    analysis += `âš ï¸  ISSUE CONFIRMED: Only 1 bookmark parsed!\n`;
                    analysis += `This is the exact problem we're trying to solve.\n\n`;
                } else {
                    analysis += `âœ… Multiple bookmarks parsed successfully!\n\n`;
                }

                // Show first 10 items
                analysis += `FIRST 10 PARSED ITEMS:\n`;
                bookmarks.slice(0, 10).forEach((item, index) => {
                    const pathStr = item.path.length > 0 ? ` [${item.path.join(' > ')}]` : '';
                    analysis += `${index + 1}. [${item.type}] ${item.title}${pathStr}\n`;
                    if (item.url) {
                        analysis += `   URL: ${item.url.substring(0, 60)}...\n`;
                    }
                });

                if (bookmarks.length > 10) {
                    analysis += `... and ${bookmarks.length - 10} more items\n`;
                }

                resultDiv.className = bookmarkItems.length > 1 ? 'result success' : 'result error';
                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `âŒ Parsing test failed: ${error.message}\n\nStack trace:\n${error.stack}`;
            }
        }

        // Test alternative parser
        async function testAlternativeParser() {
            const resultDiv = document.getElementById('parsing-test');
            
            if (!globalFileContent) {
                resultDiv.innerHTML = 'âŒ Please select a file first in Step 1';
                resultDiv.className = 'result error';
                return;
            }

            resultDiv.innerHTML = 'ðŸ”„ Testing alternative parsing approach...';
            resultDiv.className = 'result info';

            try {
                // Alternative parsing approach - more aggressive
                const bookmarks = parseBookmarkHTMLAlternative(globalFileContent);

                let analysis = `ALTERNATIVE PARSER RESULTS\n`;
                analysis += `==========================\n\n`;
                analysis += `Total items parsed: ${bookmarks.length}\n\n`;

                const bookmarkItems = bookmarks.filter(b => b.type === 'bookmark');
                const folderItems = bookmarks.filter(b => b.type === 'folder');

                analysis += `BREAKDOWN:\n`;
                analysis += `- Bookmarks: ${bookmarkItems.length}\n`;
                analysis += `- Folders: ${folderItems.length}\n\n`;

                // Compare with original parser
                if (globalBookmarkData) {
                    const originalBookmarks = globalBookmarkData.filter(b => b.type === 'bookmark').length;
                    analysis += `COMPARISON WITH ORIGINAL PARSER:\n`;
                    analysis += `- Original parser: ${originalBookmarks} bookmarks\n`;
                    analysis += `- Alternative parser: ${bookmarkItems.length} bookmarks\n`;
                    analysis += `- Improvement: ${bookmarkItems.length - originalBookmarks} additional bookmarks\n\n`;
                }

                // Show results
                analysis += `FIRST 10 PARSED ITEMS:\n`;
                bookmarks.slice(0, 10).forEach((item, index) => {
                    const pathStr = item.path.length > 0 ? ` [${item.path.join(' > ')}]` : '';
                    analysis += `${index + 1}. [${item.type}] ${item.title}${pathStr}\n`;
                });

                resultDiv.className = bookmarkItems.length > 1 ? 'result success' : 'result warning';
                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `âŒ Alternative parsing failed: ${error.message}`;
            }
        }

        // Step 3: Simulate import
        async function simulateImport() {
            const resultDiv = document.getElementById('import-simulation');
            resultDiv.style.display = 'block';
            
            if (!globalBookmarkData) {
                resultDiv.innerHTML = 'âŒ Please run parsing test first in Step 2';
                resultDiv.className = 'result error';
                return;
            }

            resultDiv.innerHTML = 'ðŸ”„ Simulating Chrome bookmark import...';
            resultDiv.className = 'result info';

            try {
                // Create test folder
                const testFolder = await chrome.bookmarks.create({
                    parentId: '1',
                    title: `Import_Test_${Date.now()}`
                });

                let analysis = `CHROME API IMPORT SIMULATION\n`;
                analysis += `============================\n\n`;
                analysis += `Test folder created: ${testFolder.title} (ID: ${testFolder.id})\n\n`;

                const bookmarkItems = globalBookmarkData.filter(b => b.type === 'bookmark');
                analysis += `Attempting to import ${bookmarkItems.length} bookmarks...\n\n`;

                let successCount = 0;
                let errorCount = 0;

                // Try to import first 5 bookmarks to test
                const testBookmarks = bookmarkItems.slice(0, 5);
                
                for (let i = 0; i < testBookmarks.length; i++) {
                    const bookmark = testBookmarks[i];
                    
                    try {
                        analysis += `${i + 1}. Importing: ${bookmark.title}\n`;
                        
                        if (i > 0) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }

                        const created = await chrome.bookmarks.create({
                            parentId: testFolder.id,
                            title: bookmark.title,
                            url: bookmark.url
                        });

                        analysis += `   âœ… SUCCESS (ID: ${created.id})\n`;
                        successCount++;

                    } catch (error) {
                        analysis += `   âŒ FAILED: ${error.message}\n`;
                        errorCount++;
                    }
                }

                analysis += `\nIMPORT RESULTS:\n`;
                analysis += `- Successful: ${successCount}\n`;
                analysis += `- Failed: ${errorCount}\n`;
                analysis += `- Success rate: ${((successCount / testBookmarks.length) * 100).toFixed(1)}%\n\n`;

                if (successCount === testBookmarks.length) {
                    analysis += `âœ… All test bookmarks imported successfully!\n`;
                    analysis += `The parsing logic appears to be working correctly.\n`;
                    resultDiv.className = 'result success';
                } else if (successCount > 0) {
                    analysis += `âš ï¸ Partial success - some bookmarks failed to import.\n`;
                    resultDiv.className = 'result warning';
                } else {
                    analysis += `âŒ Complete failure - no bookmarks imported.\n`;
                    resultDiv.className = 'result error';
                }

                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `âŒ Import simulation failed: ${error.message}`;
            }
        }

        // Test single bookmark creation
        async function testSingleBookmark() {
            const resultDiv = document.getElementById('import-simulation');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = 'ðŸ”„ Testing single bookmark creation...';
            resultDiv.className = 'result info';

            try {
                const testBookmark = await chrome.bookmarks.create({
                    parentId: '1',
                    title: 'Test Bookmark - ' + Date.now(),
                    url: 'https://example.com'
                });

                let analysis = `SINGLE BOOKMARK TEST\n`;
                analysis += `===================\n\n`;
                analysis += `âœ… Single bookmark creation: SUCCESS\n`;
                analysis += `Created bookmark ID: ${testBookmark.id}\n`;
                analysis += `Title: ${testBookmark.title}\n`;
                analysis += `URL: ${testBookmark.url}\n\n`;
                analysis += `This confirms Chrome bookmark API is working correctly.\n`;
                analysis += `The issue is likely in the parsing or batch import logic.`;

                resultDiv.className = 'result success';
                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `âŒ Single bookmark test failed: ${error.message}`;
            }
        }

        // Helper functions
        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('File read failed'));
                reader.readAsText(file, 'UTF-8');
            });
        }

        function getMaxNestingDepth(element, currentDepth = 0) {
            let maxDepth = currentDepth;
            const children = element.children;
            
            for (let child of children) {
                if (child.tagName === 'DL') {
                    const childDepth = getMaxNestingDepth(child, currentDepth + 1);
                    maxDepth = Math.max(maxDepth, childDepth);
                }
            }
            
            return maxDepth;
        }

        // Current parsing function (copy from bookmarks.js)
        function parseBookmarkHTML(htmlContent) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const bookmarks = [];

            const processElement = (element, parentPath = []) => {
                if (!element || !element.children) return;
                
                const children = Array.from(element.children);
                console.log(`ðŸ” Processing: ${element.tagName}, children: ${children.length}, path: ${parentPath.join(' > ')}`);

                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    console.log(`ðŸ“ Child ${i + 1}/${children.length}: ${child.tagName}`);
                    
                    if (child.tagName === 'DT') {
                        const link = child.querySelector('a');
                        const folder = child.querySelector('h3');

                        if (link && link.href) {
                            const bookmark = {
                                type: 'bookmark',
                                title: link.textContent.trim() || 'Untitled',
                                url: link.href,
                                path: [...parentPath]
                            };
                            bookmarks.push(bookmark);
                            console.log(`ðŸ“– Found bookmark: ${bookmark.title}`);
                        } else if (folder) {
                            const folderName = folder.textContent.trim() || 'Untitled Folder';
                            
                            if (folderName === 'Untitled Folder' && parentPath.length === 0) {
                                console.log(`â­ï¸ Skipping root Untitled Folder`);
                                const dl = child.querySelector('dl');
                                if (dl) {
                                    processElement(dl, parentPath);
                                }
                                continue;
                            }

                            const folderPath = [...parentPath, folderName];
                            bookmarks.push({
                                type: 'folder',
                                title: folderName,
                                path: [...parentPath]
                            });

                            let foundDL = null;
                            const nextSibling = child.nextElementSibling;
                            if (nextSibling && nextSibling.tagName === 'DL') {
                                foundDL = nextSibling;
                            } else {
                                const dl = child.querySelector('dl');
                                if (dl) foundDL = dl;
                            }

                            if (foundDL) {
                                processElement(foundDL, folderPath);
                            }
                        }
                    } else if (child.tagName === 'DL') {
                        processElement(child, parentPath);
                    }
                }
            };

            const rootDL = doc.querySelector('dl');
            if (rootDL) {
                processElement(rootDL);
            }

            return bookmarks;
        }

        // Alternative parsing approach
        function parseBookmarkHTMLAlternative(htmlContent) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const bookmarks = [];

            // Find all links directly
            const allLinks = doc.querySelectorAll('a[href]');
            console.log(`ðŸ” Alternative parser found ${allLinks.length} links directly`);

            allLinks.forEach((link, index) => {
                if (link.href && link.href.startsWith('http')) {
                    bookmarks.push({
                        type: 'bookmark',
                        title: link.textContent.trim() || 'Untitled',
                        url: link.href,
                        path: [] // Simplified - no path tracking
                    });
                    console.log(`ðŸ“– Alternative parser - bookmark ${index + 1}: ${link.textContent.trim()}`);
                }
            });

            return bookmarks;
        }

        // Auto-run root cause analysis when page loads
        window.addEventListener('load', () => {
            const analysisDiv = document.getElementById('root-cause-analysis');
            analysisDiv.style.display = 'block';
            analysisDiv.className = 'result info';
            
            let analysis = `ROOT CAUSE ANALYSIS FRAMEWORK\n`;
            analysis += `=============================\n\n`;
            analysis += `To diagnose your bookmark import issue, follow these steps:\n\n`;
            analysis += `1. FILE FORMAT ANALYSIS:\n`;
            analysis += `   - Upload your bookmarks_2025-06-27.html file above\n`;
            analysis += `   - Check if it follows standard Netscape bookmark format\n`;
            analysis += `   - Verify the nesting structure is correct\n\n`;
            analysis += `2. PARSING LOGIC TEST:\n`;
            analysis += `   - Test current parser with your file\n`;
            analysis += `   - Compare with alternative parsing approach\n`;
            analysis += `   - Identify where parsing fails\n\n`;
            analysis += `3. CHROME API SIMULATION:\n`;
            analysis += `   - Test actual bookmark creation with Chrome API\n`;
            analysis += `   - Verify if the issue is in parsing or import logic\n\n`;
            analysis += `EXPECTED OUTCOMES:\n`;
            analysis += `- If Step 1 fails: File format issue\n`;
            analysis += `- If Step 2 fails: Parsing logic problem\n`;
            analysis += `- If Step 3 fails: Chrome API or import logic issue\n\n`;
            analysis += `Please run each step in order to identify the root cause.`;
            
            analysisDiv.innerHTML = analysis;
        });
    </script>
</body>
</html>
