<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è°ƒè¯•æ–‡ä»¶å¤¹è·¯å¾„æå–é—®é¢˜</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .test-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .test-button {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.3);
        }

        .result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 500px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }

        .result.success {
            background: rgba(34, 197, 94, 0.2);
            border: 2px solid rgba(34, 197, 94, 0.6);
        }

        .result.error {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid rgba(239, 68, 68, 0.6);
        }

        .result.info {
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid rgba(59, 130, 246, 0.6);
        }

        .file-input {
            margin: 10px 0;
            padding: 10px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ” è°ƒè¯•æ–‡ä»¶å¤¹è·¯å¾„æå–é—®é¢˜</h1>
        <p>æ·±åº¦åˆ†æä¸ºä»€ä¹ˆä¹¦ç­¾æ²¡æœ‰æ­£ç¡®åˆ†é…åˆ°æ–‡ä»¶å¤¹</p>
    </div>

    <div class="test-section">
        <h3>ğŸ“ æ·±åº¦è·¯å¾„æå–è°ƒè¯•</h3>
        <div class="file-input">
            <input type="file" id="bookmark-file" accept=".html" onchange="deepDebugPathExtraction(event)">
            <p>é€‰æ‹©ä½ çš„ bookmarks_2025-06-27.html æ–‡ä»¶</p>
        </div>
        <button class="test-button" onclick="testWithKnownStructure()">ä½¿ç”¨å·²çŸ¥ç»“æ„æµ‹è¯•</button>
        <div id="debug-result" class="result" style="display:none;"></div>
    </div>

    <div class="test-section">
        <h3>ğŸ§ª å¤šç§è§£ææ–¹æ³•å¯¹æ¯”</h3>
        <button class="test-button" onclick="compareParsingMethods()">å¯¹æ¯”ä¸åŒè§£ææ–¹æ³•</button>
        <div id="comparison-result" class="result" style="display:none;"></div>
    </div>

    <script>
        let globalFileContent = null;

        // æ·±åº¦è°ƒè¯•è·¯å¾„æå–
        async function deepDebugPathExtraction(event) {
            const resultDiv = document.getElementById('debug-result');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = 'ğŸ”„ æ·±åº¦è°ƒè¯•è·¯å¾„æå–...';
            resultDiv.className = 'result info';

            try {
                const file = event.target.files[0];
                if (!file) return;

                const content = await readFileContent(file);
                globalFileContent = content;

                let analysis = `æ·±åº¦è·¯å¾„æå–è°ƒè¯•æŠ¥å‘Š\n`;
                analysis += `========================\n\n`;
                analysis += `æ–‡ä»¶: ${file.name}\n`;
                analysis += `å¤§å°: ${file.size} å­—èŠ‚\n\n`;

                // è§£æDOMç»“æ„
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'text/html');

                // åˆ†æDOMç»“æ„
                analysis += `DOMç»“æ„åˆ†æ:\n`;
                const allDLs = doc.querySelectorAll('dl');
                const allDTs = doc.querySelectorAll('dt');
                const allH3s = doc.querySelectorAll('h3');
                const allLinks = doc.querySelectorAll('a[href]');

                analysis += `- DLå…ƒç´ : ${allDLs.length} ä¸ª\n`;
                analysis += `- DTå…ƒç´ : ${allDTs.length} ä¸ª\n`;
                analysis += `- H3å…ƒç´ : ${allH3s.length} ä¸ª\n`;
                analysis += `- é“¾æ¥å…ƒç´ : ${allLinks.length} ä¸ª\n\n`;

                // åˆ†ææ–‡ä»¶å¤¹ç»“æ„
                analysis += `æ–‡ä»¶å¤¹ç»“æ„åˆ†æ:\n`;
                allH3s.forEach((h3, index) => {
                    const folderName = h3.textContent.trim();
                    analysis += `${index + 1}. æ–‡ä»¶å¤¹: "${folderName}"\n`;
                    
                    // åˆ†æè¿™ä¸ªæ–‡ä»¶å¤¹çš„DOMä½ç½®
                    const dt = h3.closest('dt');
                    if (dt) {
                        const parentDL = dt.parentElement;
                        if (parentDL && parentDL.tagName === 'DL') {
                            const grandparentDT = parentDL.previousElementSibling;
                            if (grandparentDT && grandparentDT.tagName === 'DT') {
                                const grandparentH3 = grandparentDT.querySelector('h3');
                                if (grandparentH3) {
                                    analysis += `   çˆ¶æ–‡ä»¶å¤¹: "${grandparentH3.textContent.trim()}"\n`;
                                }
                            }
                        }
                    }
                });

                analysis += `\nä¹¦ç­¾è·¯å¾„æå–æµ‹è¯•:\n`;
                
                // æµ‹è¯•å‰10ä¸ªä¹¦ç­¾çš„è·¯å¾„æå–
                const bookmarkLinks = Array.from(allLinks).filter(link => 
                    link.href && link.href.startsWith('http')
                ).slice(0, 10);

                bookmarkLinks.forEach((link, index) => {
                    const title = link.textContent.trim();
                    analysis += `\n${index + 1}. ä¹¦ç­¾: "${title}"\n`;
                    
                    // ä½¿ç”¨å½“å‰çš„è·¯å¾„æå–é€»è¾‘
                    const path1 = getBookmarkPathMethod1(link);
                    analysis += `   æ–¹æ³•1è·¯å¾„: [${path1.join(' > ')}]\n`;
                    
                    // ä½¿ç”¨æ”¹è¿›çš„è·¯å¾„æå–é€»è¾‘
                    const path2 = getBookmarkPathMethod2(link);
                    analysis += `   æ–¹æ³•2è·¯å¾„: [${path2.join(' > ')}]\n`;
                    
                    // ä½¿ç”¨æœ€ç®€å•çš„è·¯å¾„æå–é€»è¾‘
                    const path3 = getBookmarkPathMethod3(link);
                    analysis += `   æ–¹æ³•3è·¯å¾„: [${path3.join(' > ')}]\n`;
                    
                    // åˆ†æDOMç»“æ„
                    analysis += `   DOMåˆ†æ:\n`;
                    let current = link;
                    let level = 0;
                    while (current && current.parentElement && level < 10) {
                        current = current.parentElement;
                        if (current.tagName === 'DL') {
                            const prevSibling = current.previousElementSibling;
                            if (prevSibling && prevSibling.tagName === 'DT') {
                                const h3 = prevSibling.querySelector('h3');
                                if (h3) {
                                    analysis += `     å±‚çº§${level}: DL -> DT -> H3 "${h3.textContent.trim()}"\n`;
                                }
                            }
                        }
                        level++;
                    }
                });

                resultDiv.className = 'result info';
                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `âŒ è°ƒè¯•å¤±è´¥: ${error.message}\n\nStack trace:\n${error.stack}`;
            }
        }

        // ä½¿ç”¨å·²çŸ¥ç»“æ„æµ‹è¯•
        function testWithKnownStructure() {
            const resultDiv = document.getElementById('debug-result');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = 'ğŸ”„ ä½¿ç”¨å·²çŸ¥ç»“æ„æµ‹è¯•...';
            resultDiv.className = 'result info';

            // åŸºäºä½ çš„å®é™…æ–‡ä»¶ç»“æ„çš„æµ‹è¯•HTML
            const testHTML = `<!DOCTYPE NETSCAPE-Bookmark-file-1>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DL><p>
<DT><H3>Untitled Folder</H3>
<DL><p>
  <DT><H3>æ”¶è—å¤¹æ </H3>
  <DL><p>
    <DT><H3>work-assist</H3>
    <DL><p>
      <DT><A HREF="https://aflowmind.com/app/mindmap/6E1-YDYVBAN4ORDO7PSH">AflowMind: The AI Mind Mapping Tool</A>
      <DT><A HREF="https://app.amymind.com/mindmap/new">AmyMind</A>
    </DL><p>
    <DT><H3>AI-Chat</H3>
    <DL><p>
      <DT><A HREF="https://chat.openai.com/chat">ChatGPT</A>
      <DT><A HREF="https://gemini.google.com/u/1/app/74a659aed20881f2">Gemini Advanced</A>
    </DL><p>
    <DT><A HREF="https://github.com/">GitHub (æ ¹çº§åˆ«)</A>
  </DL><p>
</DL><p>
</DL><p>`;

            try {
                let analysis = `å·²çŸ¥ç»“æ„æµ‹è¯•ç»“æœ\n`;
                analysis += `==================\n\n`;
                analysis += `æœŸæœ›ç»“æœ:\n`;
                analysis += `- AflowMind: [æ”¶è—å¤¹æ , work-assist]\n`;
                analysis += `- AmyMind: [æ”¶è—å¤¹æ , work-assist]\n`;
                analysis += `- ChatGPT: [æ”¶è—å¤¹æ , AI-Chat]\n`;
                analysis += `- Gemini: [æ”¶è—å¤¹æ , AI-Chat]\n`;
                analysis += `- GitHub: [æ”¶è—å¤¹æ ]\n\n`;

                const parser = new DOMParser();
                const doc = parser.parseFromString(testHTML, 'text/html');
                const links = doc.querySelectorAll('a[href]');

                analysis += `å®é™…ç»“æœ:\n`;
                links.forEach((link, index) => {
                    const title = link.textContent.trim();
                    const path1 = getBookmarkPathMethod1(link);
                    const path2 = getBookmarkPathMethod2(link);
                    const path3 = getBookmarkPathMethod3(link);
                    
                    analysis += `${index + 1}. ${title}:\n`;
                    analysis += `   æ–¹æ³•1: [${path1.join(', ')}]\n`;
                    analysis += `   æ–¹æ³•2: [${path2.join(', ')}]\n`;
                    analysis += `   æ–¹æ³•3: [${path3.join(', ')}]\n\n`;
                });

                // æ£€æŸ¥å“ªç§æ–¹æ³•æœ€å‡†ç¡®
                const aflowmindLink = Array.from(links).find(link => 
                    link.textContent.includes('AflowMind')
                );
                
                if (aflowmindLink) {
                    const path1 = getBookmarkPathMethod1(aflowmindLink);
                    const path2 = getBookmarkPathMethod2(aflowmindLink);
                    const path3 = getBookmarkPathMethod3(aflowmindLink);
                    
                    analysis += `å‡†ç¡®æ€§æ£€æŸ¥ (AflowMindåº”è¯¥åœ¨ [æ”¶è—å¤¹æ , work-assist]):\n`;
                    analysis += `- æ–¹æ³•1: ${path1.includes('work-assist') && path1.includes('æ”¶è—å¤¹æ ') ? 'âœ… æ­£ç¡®' : 'âŒ é”™è¯¯'}\n`;
                    analysis += `- æ–¹æ³•2: ${path2.includes('work-assist') && path2.includes('æ”¶è—å¤¹æ ') ? 'âœ… æ­£ç¡®' : 'âŒ é”™è¯¯'}\n`;
                    analysis += `- æ–¹æ³•3: ${path3.includes('work-assist') && path3.includes('æ”¶è—å¤¹æ ') ? 'âœ… æ­£ç¡®' : 'âŒ é”™è¯¯'}\n`;
                }

                resultDiv.className = 'result info';
                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `âŒ æµ‹è¯•å¤±è´¥: ${error.message}`;
            }
        }

        // å¯¹æ¯”ä¸åŒè§£ææ–¹æ³•
        function compareParsingMethods() {
            const resultDiv = document.getElementById('comparison-result');
            resultDiv.style.display = 'block';

            if (!globalFileContent) {
                resultDiv.innerHTML = 'âŒ è¯·å…ˆé€‰æ‹©æ–‡ä»¶è¿›è¡Œè°ƒè¯•';
                resultDiv.className = 'result error';
                return;
            }

            resultDiv.innerHTML = 'ğŸ”„ å¯¹æ¯”ä¸åŒè§£ææ–¹æ³•...';
            resultDiv.className = 'result info';

            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(globalFileContent, 'text/html');
                const links = Array.from(doc.querySelectorAll('a[href]')).filter(link => 
                    link.href && link.href.startsWith('http')
                ).slice(0, 20);

                let analysis = `è§£ææ–¹æ³•å¯¹æ¯”ç»“æœ\n`;
                analysis += `==================\n\n`;
                analysis += `æµ‹è¯• ${links.length} ä¸ªä¹¦ç­¾çš„è·¯å¾„æå–\n\n`;

                const method1Results = {};
                const method2Results = {};
                const method3Results = {};

                links.forEach((link, index) => {
                    const title = link.textContent.trim();
                    const path1 = getBookmarkPathMethod1(link);
                    const path2 = getBookmarkPathMethod2(link);
                    const path3 = getBookmarkPathMethod3(link);
                    
                    const pathKey1 = path1.length > 0 ? path1.join(' > ') : 'ROOT';
                    const pathKey2 = path2.length > 0 ? path2.join(' > ') : 'ROOT';
                    const pathKey3 = path3.length > 0 ? path3.join(' > ') : 'ROOT';
                    
                    method1Results[pathKey1] = (method1Results[pathKey1] || 0) + 1;
                    method2Results[pathKey2] = (method2Results[pathKey2] || 0) + 1;
                    method3Results[pathKey3] = (method3Results[pathKey3] || 0) + 1;
                });

                analysis += `æ–¹æ³•1ç»“æœåˆ†å¸ƒ:\n`;
                Object.entries(method1Results).forEach(([path, count]) => {
                    analysis += `- "${path}": ${count} ä¸ªä¹¦ç­¾\n`;
                });

                analysis += `\næ–¹æ³•2ç»“æœåˆ†å¸ƒ:\n`;
                Object.entries(method2Results).forEach(([path, count]) => {
                    analysis += `- "${path}": ${count} ä¸ªä¹¦ç­¾\n`;
                });

                analysis += `\næ–¹æ³•3ç»“æœåˆ†å¸ƒ:\n`;
                Object.entries(method3Results).forEach(([path, count]) => {
                    analysis += `- "${path}": ${count} ä¸ªä¹¦ç­¾\n`;
                });

                // åˆ†æå“ªç§æ–¹æ³•æœ€å¥½
                const method1RootCount = method1Results['ROOT'] || 0;
                const method2RootCount = method2Results['ROOT'] || 0;
                const method3RootCount = method3Results['ROOT'] || 0;

                analysis += `\nåˆ†æç»“æœ:\n`;
                analysis += `- æ–¹æ³•1: ${method1RootCount}/${links.length} ä¸ªä¹¦ç­¾åœ¨æ ¹ç›®å½•\n`;
                analysis += `- æ–¹æ³•2: ${method2RootCount}/${links.length} ä¸ªä¹¦ç­¾åœ¨æ ¹ç›®å½•\n`;
                analysis += `- æ–¹æ³•3: ${method3RootCount}/${links.length} ä¸ªä¹¦ç­¾åœ¨æ ¹ç›®å½•\n\n`;

                const bestMethod = method1RootCount <= method2RootCount && method1RootCount <= method3RootCount ? 1 :
                                 method2RootCount <= method3RootCount ? 2 : 3;

                analysis += `æ¨èä½¿ç”¨æ–¹æ³•${bestMethod}ï¼Œå› ä¸ºå®ƒå°†æœ€å°‘çš„ä¹¦ç­¾æ”¾åœ¨æ ¹ç›®å½•ã€‚`;

                resultDiv.className = 'result success';
                resultDiv.innerHTML = analysis;

            } catch (error) {
                resultDiv.className = 'result error';
                resultDiv.innerHTML = `âŒ å¯¹æ¯”å¤±è´¥: ${error.message}`;
            }
        }

        // è·¯å¾„æå–æ–¹æ³•1 (å½“å‰ä½¿ç”¨çš„)
        function getBookmarkPathMethod1(linkElement) {
            const path = [];
            let current = linkElement;
            
            while (current && current.parentElement) {
                current = current.parentElement;
                
                if (current.tagName === 'DL') {
                    let folderDT = current.previousElementSibling;
                    
                    while (folderDT && folderDT.nodeType !== Node.ELEMENT_NODE) {
                        folderDT = folderDT.previousSibling;
                    }
                    
                    if (folderDT && folderDT.tagName === 'DT') {
                        const folderH3 = folderDT.querySelector('h3');
                        if (folderH3) {
                            const folderName = folderH3.textContent.trim();
                            if (folderName !== 'Untitled Folder') {
                                path.unshift(folderName);
                            }
                        }
                    }
                }
            }
            
            return path;
        }

        // è·¯å¾„æå–æ–¹æ³•2 (æ”¹è¿›ç‰ˆ)
        function getBookmarkPathMethod2(linkElement) {
            const path = [];
            let current = linkElement.closest('dt');
            
            while (current) {
                const parentDL = current.parentElement;
                if (parentDL && parentDL.tagName === 'DL') {
                    const folderDT = parentDL.previousElementSibling;
                    if (folderDT && folderDT.tagName === 'DT') {
                        const folderH3 = folderDT.querySelector('h3');
                        if (folderH3) {
                            const folderName = folderH3.textContent.trim();
                            if (folderName !== 'Untitled Folder') {
                                path.unshift(folderName);
                            }
                        }
                    }
                    current = folderDT;
                } else {
                    break;
                }
            }
            
            return path;
        }

        // è·¯å¾„æå–æ–¹æ³•3 (æœ€ç®€å•)
        function getBookmarkPathMethod3(linkElement) {
            const path = [];
            let element = linkElement;
            
            // å‘ä¸ŠæŸ¥æ‰¾æ‰€æœ‰åŒ…å«çš„DLå…ƒç´ 
            while (element) {
                element = element.parentElement;
                if (element && element.tagName === 'DL') {
                    // æŸ¥æ‰¾è¿™ä¸ªDLå¯¹åº”çš„æ–‡ä»¶å¤¹å
                    const prevElement = element.previousElementSibling;
                    if (prevElement && prevElement.tagName === 'DT') {
                        const h3 = prevElement.querySelector('h3');
                        if (h3) {
                            const folderName = h3.textContent.trim();
                            if (folderName !== 'Untitled Folder') {
                                path.unshift(folderName);
                            }
                        }
                    }
                }
            }
            
            return path;
        }

        // è¾…åŠ©å‡½æ•°
        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                reader.readAsText(file, 'UTF-8');
            });
        }
    </script>
</body>
</html>
